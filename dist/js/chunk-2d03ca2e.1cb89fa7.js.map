{"version":3,"sources":["webpack:///./node_modules/core-js/modules/es.string.split.js","webpack:///./node_modules/vue-request/dist/index.es.js","webpack:///./node_modules/core-js/internals/is-regexp.js","webpack:///./node_modules/core-js/internals/array-slice-simple.js","webpack:///./node_modules/core-js/internals/advance-string-index.js","webpack:///./node_modules/core-js/modules/es.function.name.js"],"names":["apply","call","uncurryThis","fixRegExpWellKnownSymbolLogic","isRegExp","anObject","requireObjectCoercible","speciesConstructor","advanceStringIndex","toLength","toString","getMethod","arraySlice","callRegExpExec","regexpExec","stickyHelpers","fails","UNSUPPORTED_Y","MAX_UINT32","min","Math","$push","push","exec","stringSlice","slice","SPLIT_WORKS_WITH_OVERWRITTEN_EXEC","re","originalExec","this","arguments","result","split","length","SPLIT","nativeSplit","maybeCallNative","internalSplit","separator","limit","string","lim","undefined","match","lastIndex","lastLength","output","flags","ignoreCase","multiline","unicode","sticky","lastLastIndex","separatorCopy","RegExp","source","index","O","splitter","rx","S","res","done","value","C","unicodeMatching","p","q","A","e","z","i","GLOBAL_OPTIONS","GLOBAL_OPTIONS_PROVIDE_KEY","Symbol","getGlobalOptions","objectToString","name","props","config","type","Object","required","slots","_slots$default","default","prototype","toTypeString","val","isString","isPlainObject","isObject","isPromise","fn","isFunction","then","catch","Function","isNil","isServer","window","isDocumentVisibility","_window","_window$document","document","visibilityState","isOnline","_ref","_window2","_window2$navigator","navigator","onLine","unRefObject","obj","keys","forEach","key","resolvedPromise","Promise","resolve","requestProxy","async","args","fetch","ok","json","Error","statusText","omit","object","assign","warning","message","throwError","msg","console","error","limitTrigger","timeInterval","running","setTimeout","FOCUS_LISTENER","Set","VISIBLE_LISTENER","RECONNECT_LISTENER","subscriber","listenerType","event","listeners","has","add","delete","observer","debounce","func","wait","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","requestAnimationFrame","TypeError","invokeFunc","time","thisArg","startTimer","pendingFunc","cancelAnimationFrame","cancelTimer","id","clearTimeout","leadingEdge","timerExpired","remainingWait","timeSinceLastCall","timeSinceLastInvoke","timeWaiting","shouldInvoke","Date","now","trailingEdge","cancel","flush","pending","debounced","isInvoking","max","throttle","addEventListener","setStateBind","oldState","publicCb","newState","fun","createQuery","query","initialState","_initialState$loading","_initialState$data","_initialState$params","initialAutoRunFlag","initialData","loadingDelay","pollingInterval","debounceInterval","debounceOptions","throttleInterval","throttleOptions","pollingWhenHidden","pollingWhenOffline","errorRetryCount","errorRetryInterval","stopPollingWhenHiddenOrOffline","refreshOnWindowFocus","refocusTimespan","updateCache","formatResult","onSuccess","onError","onBefore","onAfter","retriedCount","loading","data","params","setState","state","resetRetriedCount","count","pollingTimer","retryTimer","delayLoadingTimer","clearAllTimer","delayLoading","polling","pollingFunc","actualErrorRetryInterval","baseTime","minCoefficient","maxCoefficient","coefficient","floor","random","errorRetryHooks","retryFunc","isInfiniteRetry","hasRetryCount","_run","currentCount","formattedResult","finally","debouncedRun","throttledRun","run","refresh","mutate","x","mutateData","unsubscribeList","addUnsubscribeList","rePolling","limitRefresh","unmount","unsubscribe","CACHE_MAP","Map","getCache","cacheKey","get","cacheTime","setCache","oldCache","timer","set","getTime","QUERY_DEFAULT_KEY","useAsyncQuery","injectedGlobalOptions","defaultParams","manual","ready","refreshDeps","staleTime","queryKey","rest","_getCache","_queryKey","cacheData","cacheQueries","queries","queryData","currentQueryKey","latestQueriesKey","latestQuery","_queries$latestQuerie","immediate","deep","_cache$data","cache","cacheQuery","tempReadyParams","hasTriggerReady","_queryKey2","newKey","reset","unmountQueries","arg","_cache$data$queries","isFresh","hasCacheQueries","_queries$key","stopReady","generateService","service","url","useRequest","promiseQuery","reloading","reload","classof","wellKnownSymbol","MATCH","module","exports","it","global","toAbsoluteIndex","lengthOfArrayLike","createProperty","Array","start","end","k","fin","n","charAt","DESCRIPTORS","FUNCTION_NAME_EXISTS","EXISTS","defineProperty","f","FunctionPrototype","functionToString","nameRE","regExpExec","NAME","configurable"],"mappings":"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","file":"js/chunk-2d03ca2e.1cb89fa7.js","sourcesContent":["'use strict';\nvar apply = require('../internals/function-apply');\nvar call = require('../internals/function-call');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');\nvar isRegExp = require('../internals/is-regexp');\nvar anObject = require('../internals/an-object');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\nvar speciesConstructor = require('../internals/species-constructor');\nvar advanceStringIndex = require('../internals/advance-string-index');\nvar toLength = require('../internals/to-length');\nvar toString = require('../internals/to-string');\nvar getMethod = require('../internals/get-method');\nvar arraySlice = require('../internals/array-slice-simple');\nvar callRegExpExec = require('../internals/regexp-exec-abstract');\nvar regexpExec = require('../internals/regexp-exec');\nvar stickyHelpers = require('../internals/regexp-sticky-helpers');\nvar fails = require('../internals/fails');\n\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;\nvar MAX_UINT32 = 0xFFFFFFFF;\nvar min = Math.min;\nvar $push = [].push;\nvar exec = uncurryThis(/./.exec);\nvar push = uncurryThis($push);\nvar stringSlice = uncurryThis(''.slice);\n\n// Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n// Weex JS has frozen built-in prototypes, so use try / catch wrapper\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {\n  // eslint-disable-next-line regexp/no-empty-group -- required for testing\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';\n});\n\n// @@split logic\nfixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {\n  var internalSplit;\n  if (\n    'abbc'.split(/(b)*/)[1] == 'c' ||\n    // eslint-disable-next-line regexp/no-empty-group -- required for testing\n    'test'.split(/(?:)/, -1).length != 4 ||\n    'ab'.split(/(?:ab)*/).length != 2 ||\n    '.'.split(/(.?)(.?)/).length != 4 ||\n    // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing\n    '.'.split(/()()/).length > 1 ||\n    ''.split(/.?/).length\n  ) {\n    // based on es5-shim implementation, need to rework it\n    internalSplit = function (separator, limit) {\n      var string = toString(requireObjectCoercible(this));\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (separator === undefined) return [string];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) {\n        return call(nativeSplit, string, separator, lim);\n      }\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var match, lastIndex, lastLength;\n      while (match = call(regexpExec, separatorCopy, string)) {\n        lastIndex = separatorCopy.lastIndex;\n        if (lastIndex > lastLastIndex) {\n          push(output, stringSlice(string, lastLastIndex, match.index));\n          if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));\n          lastLength = match[0].length;\n          lastLastIndex = lastIndex;\n          if (output.length >= lim) break;\n        }\n        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string.length) {\n        if (lastLength || !exec(separatorCopy, '')) push(output, '');\n      } else push(output, stringSlice(string, lastLastIndex));\n      return output.length > lim ? arraySlice(output, 0, lim) : output;\n    };\n  // Chakra, V8\n  } else if ('0'.split(undefined, 0).length) {\n    internalSplit = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);\n    };\n  } else internalSplit = nativeSplit;\n\n  return [\n    // `String.prototype.split` method\n    // https://tc39.es/ecma262/#sec-string.prototype.split\n    function split(separator, limit) {\n      var O = requireObjectCoercible(this);\n      var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);\n      return splitter\n        ? call(splitter, separator, O, limit)\n        : call(internalSplit, toString(O), separator, limit);\n    },\n    // `RegExp.prototype[@@split]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split\n    //\n    // NOTE: This cannot be properly polyfilled in engines that don't support\n    // the 'y' flag.\n    function (string, limit) {\n      var rx = anObject(this);\n      var S = toString(string);\n      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);\n\n      if (res.done) return res.value;\n\n      var C = speciesConstructor(rx, RegExp);\n\n      var unicodeMatching = rx.unicode;\n      var flags = (rx.ignoreCase ? 'i' : '') +\n                  (rx.multiline ? 'm' : '') +\n                  (rx.unicode ? 'u' : '') +\n                  (UNSUPPORTED_Y ? 'g' : 'y');\n\n      // ^(? + rx + ) is needed, in combination with some S slicing, to\n      // simulate the 'y' flag.\n      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];\n      var p = 0;\n      var q = 0;\n      var A = [];\n      while (q < S.length) {\n        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;\n        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);\n        var e;\n        if (\n          z === null ||\n          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p\n        ) {\n          q = advanceStringIndex(S, q, unicodeMatching);\n        } else {\n          push(A, stringSlice(S, p, q));\n          if (A.length === lim) return A;\n          for (var i = 1; i <= z.length - 1; i++) {\n            push(A, z[i]);\n            if (A.length === lim) return A;\n          }\n          q = p = e;\n        }\n      }\n      push(A, stringSlice(S, p));\n      return A;\n    }\n  ];\n}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);\n","import { defineComponent, provide, unref, ref, computed, inject, reactive, watch, onUnmounted, watchEffect } from 'vue';\n\nconst GLOBAL_OPTIONS = {};\nconst GLOBAL_OPTIONS_PROVIDE_KEY = Symbol('GLOBAL_OPTIONS_PROVIDE_KEY');\nconst setGlobalOptions = config => {\n  Object.keys(config).forEach(key => {\n    GLOBAL_OPTIONS[key] = config[key];\n  });\n};\nconst getGlobalOptions = () => {\n  return GLOBAL_OPTIONS;\n};\n\nconst RequestConfig = defineComponent({\n  name: 'RequestConfig',\n  props: {\n    config: {\n      type: Object,\n      required: true\n    }\n  },\n\n  setup(props, {\n    slots\n  }) {\n    const {\n      config\n    } = props;\n    provide(GLOBAL_OPTIONS_PROVIDE_KEY, config);\n    return () => {\n      var _slots$default;\n\n      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);\n    };\n  }\n\n});\n\nconst objectToString = Object.prototype.toString;\nconst toTypeString = val => objectToString.call(val);\nconst isString = val => toTypeString(val) === '[object String]';\nconst isPlainObject = val => toTypeString(val) === '[object Object]';\nconst isArray = val => Array.isArray(val);\nconst isObject = val => val !== null && typeof val === 'object';\nconst isPromise = fn => isObject(fn) && isFunction(fn.then) && isFunction(fn.catch);\nconst isFunction = fn => fn instanceof Function;\nconst isNil = val => val === null || val === undefined;\nconst isServer = typeof window === 'undefined';\nconst isDocumentVisibility = () => {\n  var _window, _window$document;\n\n  return !isServer && ((_window = window) === null || _window === void 0 ? void 0 : (_window$document = _window.document) === null || _window$document === void 0 ? void 0 : _window$document.visibilityState) === 'visible';\n};\nconst isOnline = () => {\n  var _ref, _window2, _window2$navigator;\n\n  return (_ref = !isServer && ((_window2 = window) === null || _window2 === void 0 ? void 0 : (_window2$navigator = _window2.navigator) === null || _window2$navigator === void 0 ? void 0 : _window2$navigator.onLine)) !== null && _ref !== void 0 ? _ref : true;\n};\nconst unRefObject = val => {\n  const obj = {};\n  Object.keys(val).forEach(key => {\n    obj[key] = unref(val[key]);\n  });\n  return obj;\n};\nconst resolvedPromise = Promise.resolve(null);\nconst requestProxy = async (...args) => {\n  const res = await fetch(...args);\n\n  if (res.ok) {\n    return res.json();\n  }\n\n  throw new Error(res.statusText);\n};\nconst get = (source, path, defaultValue = undefined) => {\n  // a[3].b -> a.3.b\n  const paths = path.replace(/\\[(\\d+)\\]/g, '.$1').split('.');\n  let result = source;\n\n  for (const p of paths) {\n    result = Object(result)[p];\n\n    if (result === undefined) {\n      return defaultValue;\n    }\n  }\n\n  return result;\n};\nfunction omit(object, keys) {\n  const result = Object.assign({}, object);\n\n  for (const key of keys) {\n    delete result[key];\n  }\n\n  return result;\n}\nconst warning = (message, throwError = false) => {\n  const msg = `Warning: [vue-request] ${message}`;\n\n  if (throwError) {\n    return new Error(msg);\n  } else {\n    console.error(msg);\n  }\n};\n\nconst limitTrigger = (fn, timeInterval) => {\n  let running = false;\n  return (...args) => {\n    if (running) return;\n    running = true;\n    fn(...args);\n    setTimeout(() => {\n      running = false;\n    }, timeInterval);\n  };\n};\n\nvar _window;\nconst FOCUS_LISTENER = new Set();\nconst VISIBLE_LISTENER = new Set();\nconst RECONNECT_LISTENER = new Set();\n\nconst subscriber = (listenerType, event) => {\n  let listeners;\n\n  switch (listenerType) {\n    case 'FOCUS_LISTENER':\n      listeners = FOCUS_LISTENER;\n      break;\n\n    case 'RECONNECT_LISTENER':\n      listeners = RECONNECT_LISTENER;\n      break;\n\n    case 'VISIBLE_LISTENER':\n      listeners = VISIBLE_LISTENER;\n      break;\n  }\n\n  if (listeners.has(event)) return;\n  listeners.add(event);\n  return () => {\n    listeners.delete(event);\n  };\n};\n\nconst observer = listeners => {\n  listeners.forEach(event => {\n    event();\n  });\n};\n/* istanbul ignore else */\n\n\nif (!isServer && (_window = window) !== null && _window !== void 0 && _window.addEventListener) {\n  window.addEventListener('visibilitychange', () => {\n    /* istanbul ignore else */\n    if (isDocumentVisibility()) {\n      observer(VISIBLE_LISTENER);\n    }\n  }, false);\n  window.addEventListener('focus', () => observer(FOCUS_LISTENER), false);\n  window.addEventListener('online', () => observer(RECONNECT_LISTENER), false);\n}\n\n/**\r\n * source by `lodash`\r\n * https://github.com/lodash/lodash.git\r\n */\n\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true; // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n\n  const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  wait = +wait || 0;\n\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      window.cancelAnimationFrame(timerId);\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = startTimer(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n    return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n    lastArgs = args;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n  return debounced;\n}\n\nfunction baseMerge(origin, target) {\n  for (const key in target) {\n    if (target[key] === undefined) {\n      continue;\n    }\n\n    if (!isObject(target[key]) || // `target[key]` is not an object\n    !isObject(origin[key]) || // `target[key]` is not an object\n    !(key in origin) // `key` is not in the origin object\n    ) {\n        origin[key] = target[key];\n        continue;\n      }\n\n    if (isPlainObject(target[key]) || isArray(target[key])) {\n      baseMerge(origin[key], target[key]);\n    }\n  }\n}\n\nfunction merge(origin, ...others) {\n  const result = Object.assign({}, origin);\n  if (!others.length) return result;\n\n  for (const item of others) {\n    baseMerge(result, item);\n  }\n\n  return result;\n}\n\n/**\r\n * source by `lodash`\r\n * https://github.com/lodash/lodash.git\r\n */\n\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait\n  });\n}\n\nconst setStateBind = (oldState, publicCb) => {\n  return newState => {\n    Object.keys(newState).forEach(key => {\n      oldState[key].value = newState[key];\n    });\n    publicCb.forEach(fun => fun(oldState));\n  };\n};\n\nconst createQuery = (query, config, initialState) => {\n  var _initialState$loading, _initialState$data, _initialState$params;\n\n  const {\n    initialAutoRunFlag,\n    initialData,\n    loadingDelay,\n    pollingInterval,\n    debounceInterval,\n    debounceOptions,\n    throttleInterval,\n    throttleOptions,\n    pollingWhenHidden,\n    pollingWhenOffline,\n    errorRetryCount,\n    errorRetryInterval,\n    stopPollingWhenHiddenOrOffline,\n    refreshOnWindowFocus,\n    refocusTimespan,\n    updateCache,\n    formatResult,\n    onSuccess,\n    onError,\n    onBefore,\n    onAfter\n  } = config;\n  const retriedCount = ref(0);\n  const loading = ref((_initialState$loading = initialState === null || initialState === void 0 ? void 0 : initialState.loading) !== null && _initialState$loading !== void 0 ? _initialState$loading : false);\n  const data = ref((_initialState$data = initialState === null || initialState === void 0 ? void 0 : initialState.data) !== null && _initialState$data !== void 0 ? _initialState$data : initialData);\n  const error = ref(initialState === null || initialState === void 0 ? void 0 : initialState.error);\n  const params = ref((_initialState$params = initialState === null || initialState === void 0 ? void 0 : initialState.params) !== null && _initialState$params !== void 0 ? _initialState$params : []);\n  const setState = setStateBind({\n    loading,\n    data,\n    error,\n    params\n  }, [state => updateCache(state)]); // reset retried count\n\n  const resetRetriedCount = () => {\n    retriedCount.value = 0;\n  };\n\n  const count = ref(0);\n  const pollingTimer = ref();\n  const retryTimer = ref();\n  const delayLoadingTimer = ref();\n\n  const clearAllTimer = () => {\n    // clear pollingTimer\n    if (pollingTimer.value) {\n      pollingTimer.value();\n    } // clear delayLoadingTimer\n\n\n    if (delayLoadingTimer.value) {\n      delayLoadingTimer.value();\n    } // clear retryTimer\n\n\n    if (retryTimer.value) {\n      retryTimer.value();\n    }\n  };\n\n  const delayLoading = () => {\n    let timerId;\n\n    if (loadingDelay) {\n      timerId = setTimeout(setState, loadingDelay, {\n        loading: true\n      });\n    }\n\n    return () => timerId && clearTimeout(timerId);\n  };\n\n  const polling = pollingFunc => {\n    // if errorRetry is enabled, then skip this method\n    if (error.value && errorRetryCount !== 0) return;\n    let timerId;\n\n    if (!isNil(pollingInterval) && pollingInterval >= 0) {\n      if ((pollingWhenHidden || isDocumentVisibility()) && (pollingWhenOffline || isOnline())) {\n        timerId = setTimeout(pollingFunc, pollingInterval);\n      } else {\n        // stop polling\n        stopPollingWhenHiddenOrOffline.value = true;\n        return;\n      }\n    }\n\n    return () => timerId && clearTimeout(timerId);\n  };\n\n  const actualErrorRetryInterval = computed(() => {\n    if (errorRetryInterval) return errorRetryInterval;\n    const baseTime = 1000;\n    const minCoefficient = 1;\n    const maxCoefficient = 9; // When retrying for the first time, in order to avoid the coefficient being 0\n    // so replace 0 with 2, the coefficient range will become 1 - 2\n\n    const coefficient = Math.floor(Math.random() * 2 ** Math.min(retriedCount.value, maxCoefficient) + minCoefficient);\n    return baseTime * coefficient;\n  });\n\n  const errorRetryHooks = retryFunc => {\n    let timerId;\n    const isInfiniteRetry = errorRetryCount === -1;\n    const hasRetryCount = retriedCount.value < errorRetryCount; // if errorRetryCount is -1, it will retry the request until it success\n\n    if (error.value && (isInfiniteRetry || hasRetryCount)) {\n      if (!isInfiniteRetry) retriedCount.value += 1;\n      timerId = setTimeout(retryFunc, actualErrorRetryInterval.value);\n    }\n\n    return () => timerId && clearTimeout(timerId);\n  };\n\n  const _run = (...args) => {\n    setState({\n      loading: !loadingDelay,\n      params: args\n    });\n    delayLoadingTimer.value = delayLoading();\n    count.value += 1;\n    const currentCount = count.value; // onBefore hooks\n\n    onBefore === null || onBefore === void 0 ? void 0 : onBefore(args);\n    return query(...args).then(res => {\n      if (currentCount === count.value) {\n        const formattedResult = formatResult ? formatResult(res) : res;\n        setState({\n          data: formattedResult,\n          loading: false,\n          error: undefined\n        });\n\n        if (onSuccess) {\n          onSuccess(formattedResult, args);\n        }\n\n        resetRetriedCount();\n        return formattedResult;\n      }\n\n      return resolvedPromise;\n    }).catch(error => {\n      if (currentCount === count.value) {\n        setState({\n          data: undefined,\n          loading: false,\n          error: error\n        });\n\n        if (onError) {\n          onError(error, args);\n        }\n\n        console.error(error);\n      }\n\n      return resolvedPromise;\n    }).finally(() => {\n      if (currentCount === count.value) {\n        // clear delayLoadingTimer\n        delayLoadingTimer.value(); // retry\n\n        retryTimer.value = errorRetryHooks(() => _run(...args)); // run for polling\n\n        pollingTimer.value = polling(() => _run(...args)); // onAfter hooks\n\n        onAfter === null || onAfter === void 0 ? void 0 : onAfter(args);\n      }\n    });\n  };\n\n  const debouncedRun = !isNil(debounceInterval) && debounce(_run, debounceInterval, debounceOptions);\n  const throttledRun = !isNil(throttleInterval) && throttle(_run, throttleInterval, throttleOptions);\n\n  const run = (...args) => {\n    clearAllTimer(); // initial auto run should not debounce\n\n    if (!initialAutoRunFlag.value && debouncedRun) {\n      debouncedRun(...args);\n      return resolvedPromise;\n    }\n\n    if (throttledRun) {\n      throttledRun(...args);\n      return resolvedPromise;\n    }\n\n    resetRetriedCount();\n    return _run(...args);\n  };\n\n  const cancel = () => {\n    count.value += 1;\n    setState({\n      loading: false\n    });\n\n    if (debouncedRun) {\n      debouncedRun.cancel();\n    }\n\n    if (throttledRun) {\n      throttledRun.cancel();\n    }\n\n    clearAllTimer();\n  };\n\n  const refresh = () => {\n    return run(...params.value);\n  };\n\n  const mutate = x => {\n    const mutateData = isFunction(x) ? x(data.value) : x;\n    setState({\n      data: mutateData\n    });\n  }; // collect subscribers, in order to unsubscribe when the component unmounted\n\n\n  const unsubscribeList = [];\n\n  const addUnsubscribeList = event => {\n    event && unsubscribeList.push(event);\n  };\n\n  const rePolling = () => {\n    if (stopPollingWhenHiddenOrOffline.value && (pollingWhenHidden || isDocumentVisibility()) && (pollingWhenOffline || isOnline())) {\n      refresh();\n      stopPollingWhenHiddenOrOffline.value = false;\n    }\n  }; // subscribe polling\n\n\n  if (!pollingWhenHidden) {\n    addUnsubscribeList(subscriber('VISIBLE_LISTENER', rePolling));\n  } // subscribe online when pollingWhenOffline is false\n\n\n  if (!pollingWhenOffline) {\n    addUnsubscribeList(subscriber('RECONNECT_LISTENER', rePolling));\n  }\n\n  const limitRefresh = limitTrigger(refresh, refocusTimespan); // subscribe window focus or visible\n\n  if (refreshOnWindowFocus) {\n    addUnsubscribeList(subscriber('VISIBLE_LISTENER', limitRefresh));\n    addUnsubscribeList(subscriber('FOCUS_LISTENER', limitRefresh));\n  }\n\n  const unmount = () => {\n    unsubscribeList.forEach(unsubscribe => unsubscribe());\n  };\n\n  return {\n    loading,\n    data,\n    error,\n    params,\n    run,\n    cancel,\n    refresh,\n    mutate,\n    unmount\n  };\n};\n\nconst CACHE_MAP = new Map();\nconst getCache = cacheKey => {\n  if (isNil(cacheKey)) return;\n  const data = CACHE_MAP.get(cacheKey);\n  if (!data) return;\n  return {\n    data: data.data,\n    cacheTime: data.cacheTime\n  };\n};\nconst setCache = (cacheKey, data, cacheTime) => {\n  const oldCache = CACHE_MAP.get(cacheKey);\n\n  if (oldCache !== null && oldCache !== void 0 && oldCache.timer) {\n    clearTimeout(oldCache.timer);\n  }\n\n  const timer = setTimeout(() => CACHE_MAP.delete(cacheKey), cacheTime);\n  CACHE_MAP.set(cacheKey, {\n    data,\n    timer,\n    cacheTime: new Date().getTime()\n  });\n};\n\nconst QUERY_DEFAULT_KEY = '__QUERY_DEFAULT_KEY__';\n\nfunction useAsyncQuery(query, options) {\n  const injectedGlobalOptions = inject(GLOBAL_OPTIONS_PROVIDE_KEY, {});\n  const {\n    cacheKey,\n    defaultParams = [],\n    manual = false,\n    ready = ref(true),\n    refreshDeps = [],\n    loadingDelay = 0,\n    pollingWhenHidden = false,\n    pollingWhenOffline = false,\n    refreshOnWindowFocus = false,\n    refocusTimespan = 5000,\n    cacheTime = 600000,\n    staleTime = 0,\n    errorRetryCount = 0,\n    errorRetryInterval = 0,\n    queryKey,\n    ...rest\n  } = { ...getGlobalOptions(),\n    ...injectedGlobalOptions,\n    ...options\n  };\n  const stopPollingWhenHiddenOrOffline = ref(false); // skip debounce when initail run\n\n  const initialAutoRunFlag = ref(false);\n\n  const updateCache = state => {\n    var _getCache, _queryKey;\n\n    if (!cacheKey) return;\n    const cacheData = (_getCache = getCache(cacheKey)) === null || _getCache === void 0 ? void 0 : _getCache.data;\n    const cacheQueries = cacheData === null || cacheData === void 0 ? void 0 : cacheData.queries;\n    const queryData = unRefObject(state);\n    const currentQueryKey = (_queryKey = queryKey === null || queryKey === void 0 ? void 0 : queryKey(...state.params.value)) !== null && _queryKey !== void 0 ? _queryKey : QUERY_DEFAULT_KEY;\n    setCache(cacheKey, {\n      queries: { ...cacheQueries,\n        [currentQueryKey]: { ...(cacheQueries === null || cacheQueries === void 0 ? void 0 : cacheQueries[currentQueryKey]),\n          ...queryData\n        }\n      },\n      latestQueriesKey: currentQueryKey\n    }, cacheTime);\n  };\n\n  const config = {\n    initialAutoRunFlag,\n    loadingDelay,\n    pollingWhenHidden,\n    pollingWhenOffline,\n    stopPollingWhenHiddenOrOffline,\n    cacheKey,\n    errorRetryCount,\n    errorRetryInterval,\n    refreshOnWindowFocus,\n    refocusTimespan,\n    updateCache,\n    ...omit(rest, ['pagination', 'listKey'])\n  };\n  const loading = ref(false);\n  const data = ref();\n  const error = ref();\n  const params = ref();\n  const queries = reactive({\n    [QUERY_DEFAULT_KEY]: reactive(createQuery(query, config))\n  });\n  const latestQueriesKey = ref(QUERY_DEFAULT_KEY);\n  const latestQuery = computed(() => {\n    var _queries$latestQuerie;\n\n    return (_queries$latestQuerie = queries[latestQueriesKey.value]) !== null && _queries$latestQuerie !== void 0 ? _queries$latestQuerie : {};\n  }); // sync state\n\n  watch(latestQuery, queryData => {\n    loading.value = queryData.loading;\n    data.value = queryData.data;\n    error.value = queryData.error;\n    params.value = queryData.params;\n  }, {\n    immediate: true,\n    deep: true\n  }); // init queries from cache\n\n  if (cacheKey) {\n    var _cache$data;\n\n    const cache = getCache(cacheKey);\n\n    if (cache !== null && cache !== void 0 && (_cache$data = cache.data) !== null && _cache$data !== void 0 && _cache$data.queries) {\n      Object.keys(cache.data.queries).forEach(key => {\n        const cacheQuery = cache.data.queries[key];\n        queries[key] = reactive(createQuery(query, config, {\n          loading: cacheQuery.loading,\n          params: cacheQuery.params,\n          data: cacheQuery.data,\n          error: cacheQuery.error\n        }));\n      });\n      /* istanbul ignore else */\n\n      if (cache.data.latestQueriesKey) {\n        latestQueriesKey.value = cache.data.latestQueriesKey;\n      }\n    }\n  }\n\n  const tempReadyParams = ref();\n  const hasTriggerReady = ref(false);\n\n  const run = (...args) => {\n    var _queryKey2;\n\n    if (!ready.value && !hasTriggerReady.value) {\n      tempReadyParams.value = args;\n      return resolvedPromise;\n    }\n\n    const newKey = (_queryKey2 = queryKey === null || queryKey === void 0 ? void 0 : queryKey(...args)) !== null && _queryKey2 !== void 0 ? _queryKey2 : QUERY_DEFAULT_KEY;\n\n    if (!queries[newKey]) {\n      queries[newKey] = reactive(createQuery(query, config));\n    }\n\n    latestQueriesKey.value = newKey;\n    return latestQuery.value.run(...args);\n  };\n\n  const reset = () => {\n    unmountQueries();\n    latestQueriesKey.value = QUERY_DEFAULT_KEY;\n    queries[QUERY_DEFAULT_KEY] = reactive(createQuery(query, config));\n  }; // unmount queries\n\n\n  const unmountQueries = () => {\n    Object.keys(queries).forEach(key => {\n      queries[key].cancel();\n      queries[key].unmount();\n      delete queries[key];\n    });\n  };\n\n  const cancel = () => latestQuery.value.cancel();\n\n  const refresh = () => latestQuery.value.refresh();\n\n  const mutate = arg => latestQuery.value.mutate(arg); // initial run\n\n\n  if (!manual) {\n    var _cache$data$queries;\n\n    initialAutoRunFlag.value = true; // TODO: need refactor\n\n    const cache = getCache(cacheKey);\n    const cacheQueries = (_cache$data$queries = cache === null || cache === void 0 ? void 0 : cache.data.queries) !== null && _cache$data$queries !== void 0 ? _cache$data$queries : {};\n    const isFresh = cache && (staleTime === -1 || cache.cacheTime + staleTime > new Date().getTime());\n    const hasCacheQueries = Object.keys(cacheQueries).length > 0;\n\n    if (!isFresh) {\n      if (hasCacheQueries) {\n        Object.keys(queries).forEach(key => {\n          var _queries$key;\n\n          (_queries$key = queries[key]) === null || _queries$key === void 0 ? void 0 : _queries$key.refresh();\n        });\n      } else {\n        run(...defaultParams);\n      }\n    }\n\n    initialAutoRunFlag.value = false;\n  } // watch ready\n\n\n  const stopReady = ref();\n  stopReady.value = watch(ready, val => {\n    hasTriggerReady.value = true;\n\n    if (val && tempReadyParams.value) {\n      run(...tempReadyParams.value); // destroy current watch\n\n      stopReady.value();\n    }\n  }, {\n    flush: 'sync'\n  }); // watch refreshDeps\n\n  if (refreshDeps.length) {\n    watch(refreshDeps, () => {\n      !manual && latestQuery.value.refresh();\n    });\n  }\n\n  onUnmounted(() => {\n    unmountQueries();\n  });\n  return {\n    loading,\n    data,\n    error,\n    params,\n    cancel,\n    refresh,\n    mutate,\n    run,\n    reset,\n    queries\n  };\n}\n\nconst generateService = service => {\n  return (...args) => {\n    if (isFunction(service)) {\n      return generateService(service(...args))();\n    } else if (isPromise(service)) {\n      return service;\n    } else if (isPlainObject(service)) {\n      const {\n        url,\n        ...rest\n      } = service;\n      return requestProxy(url, rest);\n    } else if (isString(service)) {\n      return requestProxy(service);\n    } else {\n      throw warning('Unknown service type', true);\n    }\n  };\n};\n\nfunction useLoadMore(service, options) {\n  var _injectedGlobalOption;\n\n  if (!isFunction(service)) {\n    warning('useLoadMore only support function service');\n  }\n\n  const promiseQuery = generateService(service);\n  const injectedGlobalOptions = inject(GLOBAL_OPTIONS_PROVIDE_KEY, {});\n  const {\n    queryKey,\n    isNoMore,\n    listKey = 'list',\n    ...restOptions\n  } = Object.assign({\n    listKey: (_injectedGlobalOption = injectedGlobalOptions.listKey) !== null && _injectedGlobalOption !== void 0 ? _injectedGlobalOption : getGlobalOptions().listKey\n  }, options !== null && options !== void 0 ? options : {});\n\n  if (queryKey) {\n    warning('useLoadMore does not support concurrent request');\n  }\n\n  const refreshing = ref(false);\n  const loadingMore = ref(false);\n  const reloading = ref(false);\n  const initailIncreaseQueryKey = 0;\n  const increaseQueryKey = ref(initailIncreaseQueryKey);\n  const {\n    data,\n    params,\n    queries,\n    run,\n    reset,\n    cancel: _cancel,\n    ...rest\n  } = useAsyncQuery(promiseQuery, { ...restOptions,\n    onSuccess: (...p) => {\n      var _restOptions$onSucces;\n\n      loadingMore.value = false;\n      increaseQueryKey.value++;\n      restOptions === null || restOptions === void 0 ? void 0 : (_restOptions$onSucces = restOptions.onSuccess) === null || _restOptions$onSucces === void 0 ? void 0 : _restOptions$onSucces.call(restOptions, ...p);\n    },\n    onError: (...p) => {\n      var _restOptions$onError;\n\n      loadingMore.value = false;\n      restOptions === null || restOptions === void 0 ? void 0 : (_restOptions$onError = restOptions.onError) === null || _restOptions$onError === void 0 ? void 0 : _restOptions$onError.call(restOptions, ...p);\n    },\n    queryKey: () => String(increaseQueryKey.value)\n  });\n  const latestData = ref(data.value);\n  watchEffect(() => {\n    if (data.value !== undefined) {\n      latestData.value = data.value;\n    }\n  });\n  const noMore = computed(() => {\n    return isNoMore && isFunction(isNoMore) ? isNoMore(latestData.value) : false;\n  });\n  const dataList = computed(() => {\n    let list = [];\n    Object.values(queries).forEach(h => {\n      const dataList = get(h.data, listKey);\n\n      if (dataList && Array.isArray(dataList)) {\n        list = list.concat(dataList);\n      }\n    });\n    return list;\n  });\n\n  const loadMore = () => {\n    if (noMore.value) {\n      return;\n    }\n\n    loadingMore.value = true;\n    const [, ...restParams] = params.value;\n    const mergerParams = [{\n      dataList: dataList.value,\n      data: latestData.value\n    }, ...restParams];\n    run(...mergerParams);\n  };\n\n  const unmountQueries = () => {\n    Object.keys(queries).forEach(key => {\n      if (key !== initailIncreaseQueryKey.toString()) {\n        queries[key].cancel();\n        queries[key].unmount();\n        delete queries[key];\n      }\n    });\n  };\n\n  const refresh = async () => {\n    refreshing.value = true;\n    const latestKey = increaseQueryKey.value - 1;\n    const key = latestKey < initailIncreaseQueryKey ? initailIncreaseQueryKey : latestKey;\n    latestData.value = queries[key].data;\n    increaseQueryKey.value = initailIncreaseQueryKey;\n    const [, ...restParams] = params.value;\n    const mergerParams = [undefined, ...restParams];\n    await run(...mergerParams);\n    unmountQueries();\n    refreshing.value = false;\n  };\n\n  const reload = async () => {\n    reloading.value = true;\n    reset();\n    increaseQueryKey.value = initailIncreaseQueryKey;\n    latestData.value = undefined;\n    const [, ...restParams] = params.value;\n    const mergerParams = [undefined, ...restParams];\n    await run(...mergerParams);\n    reloading.value = false;\n  };\n\n  const cancel = () => {\n    _cancel();\n\n    loadingMore.value = false;\n    refreshing.value = false;\n  };\n\n  return {\n    data: latestData,\n    dataList: dataList,\n    params,\n    noMore,\n    loadingMore,\n    refreshing,\n    reloading,\n    run,\n    reload,\n    loadMore,\n    reset,\n    refresh,\n    cancel,\n    ...omit(rest, ['refresh', 'mutate'])\n  };\n}\n\nfunction usePagination(service, options) {\n  var _getGlobalOptions$pag, _injectedGlobalOption;\n\n  const promiseQuery = generateService(service);\n  const defaultOptions = {\n    pagination: {\n      currentKey: 'current',\n      pageSizeKey: 'pageSize',\n      totalKey: 'total',\n      totalPageKey: 'totalPage'\n    }\n  };\n  const injectedGlobalOptions = inject(GLOBAL_OPTIONS_PROVIDE_KEY, {});\n  const {\n    pagination: {\n      currentKey,\n      pageSizeKey,\n      totalKey,\n      totalPageKey\n    },\n    queryKey,\n    ...restOptions\n  } = merge(defaultOptions, {\n    pagination: (_getGlobalOptions$pag = getGlobalOptions().pagination) !== null && _getGlobalOptions$pag !== void 0 ? _getGlobalOptions$pag : {}\n  }, {\n    pagination: (_injectedGlobalOption = injectedGlobalOptions.pagination) !== null && _injectedGlobalOption !== void 0 ? _injectedGlobalOption : {}\n  }, options !== null && options !== void 0 ? options : {});\n\n  if (queryKey) {\n    warning('usePagination does not support concurrent request');\n  }\n\n  const finallyOptions = merge({\n    defaultParams: [{\n      [currentKey]: 1,\n      [pageSizeKey]: 10\n    }]\n  }, restOptions);\n  const {\n    data,\n    params,\n    queries,\n    run,\n    reset,\n    ...rest\n  } = useAsyncQuery(promiseQuery, finallyOptions);\n\n  const paging = paginationParams => {\n    const [oldPaginationParams, ...restParams] = params.value;\n    const newPaginationParams = { ...oldPaginationParams,\n      ...paginationParams\n    };\n    const mergerParams = [newPaginationParams, ...restParams];\n    run(...mergerParams);\n  }; // changeCurrent\tchange current page\t(current: number) => void\n\n\n  const changeCurrent = current => {\n    paging({\n      [currentKey]: current\n    });\n  }; // changePageSize\tchange pageSize\t(pageSize: number) => void\n\n\n  const changePageSize = pageSize => {\n    paging({\n      [pageSizeKey]: pageSize\n    });\n  }; // changePagination\tchange current and pageSize\t(current: number, pageSize: number) => void\n\n\n  const changePagination = (current, pageSize) => {\n    paging({\n      [currentKey]: current,\n      [pageSizeKey]: pageSize\n    });\n  };\n\n  const reloading = ref(false);\n\n  const reload = async () => {\n    const {\n      defaultParams,\n      manual\n    } = finallyOptions;\n    reset();\n\n    if (!manual) {\n      reloading.value = true;\n      await run(...defaultParams);\n      reloading.value = false;\n    }\n  };\n\n  const total = computed(() => get(data.value, totalKey, 0));\n  const current = computed({\n    get: () => {\n      var _params$value$0$curre, _params$value$;\n\n      return (_params$value$0$curre = (_params$value$ = params.value[0]) === null || _params$value$ === void 0 ? void 0 : _params$value$[currentKey]) !== null && _params$value$0$curre !== void 0 ? _params$value$0$curre : finallyOptions.defaultParams[0][currentKey];\n    },\n    set: val => {\n      changeCurrent(val);\n    }\n  });\n  const pageSize = computed({\n    get: () => {\n      var _params$value$0$pageS, _params$value$2;\n\n      return (_params$value$0$pageS = (_params$value$2 = params.value[0]) === null || _params$value$2 === void 0 ? void 0 : _params$value$2[pageSizeKey]) !== null && _params$value$0$pageS !== void 0 ? _params$value$0$pageS : finallyOptions.defaultParams[0][pageSizeKey];\n    },\n    set: val => {\n      changePageSize(val);\n    }\n  });\n  const totalPage = computed(() => get(data.value, totalPageKey, Math.ceil(total.value / pageSize.value)));\n  return {\n    data,\n    params,\n    current,\n    pageSize,\n    total,\n    totalPage,\n    reloading,\n    run,\n    changeCurrent,\n    changePageSize,\n    changePagination,\n    reload,\n    ...rest\n  };\n}\n\nfunction useRequest(service, options) {\n  const promiseQuery = generateService(service);\n  const {\n    reset,\n    run,\n    ...rest\n  } = useAsyncQuery(promiseQuery, options !== null && options !== void 0 ? options : {});\n  const reloading = ref(false);\n\n  const reload = async () => {\n    const {\n      defaultParams = [],\n      manual\n    } = options;\n    reset();\n\n    if (!manual) {\n      reloading.value = true;\n      await run(...defaultParams);\n      reloading.value = false;\n    }\n  };\n\n  return {\n    reload,\n    run,\n    reloading,\n    ...rest\n  };\n}\n\nexport { RequestConfig, setGlobalOptions, useLoadMore, usePagination, useRequest };\n","var isObject = require('../internals/is-object');\nvar classof = require('../internals/classof-raw');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar MATCH = wellKnownSymbol('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');\n};\n","var global = require('../internals/global');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\nvar createProperty = require('../internals/create-property');\n\nvar Array = global.Array;\nvar max = Math.max;\n\nmodule.exports = function (O, start, end) {\n  var length = lengthOfArrayLike(O);\n  var k = toAbsoluteIndex(start, length);\n  var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n  var result = Array(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n","'use strict';\nvar charAt = require('../internals/string-multibyte').charAt;\n\n// `AdvanceStringIndex` abstract operation\n// https://tc39.es/ecma262/#sec-advancestringindex\nmodule.exports = function (S, index, unicode) {\n  return index + (unicode ? charAt(S, index).length : 1);\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar FUNCTION_NAME_EXISTS = require('../internals/function-name').EXISTS;\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar defineProperty = require('../internals/object-define-property').f;\n\nvar FunctionPrototype = Function.prototype;\nvar functionToString = uncurryThis(FunctionPrototype.toString);\nvar nameRE = /function\\b(?:\\s|\\/\\*[\\S\\s]*?\\*\\/|\\/\\/[^\\n\\r]*[\\n\\r]+)*([^\\s(/]*)/;\nvar regExpExec = uncurryThis(nameRE.exec);\nvar NAME = 'name';\n\n// Function instances `.name` property\n// https://tc39.es/ecma262/#sec-function-instances-name\nif (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {\n  defineProperty(FunctionPrototype, NAME, {\n    configurable: true,\n    get: function () {\n      try {\n        return regExpExec(nameRE, functionToString(this))[1];\n      } catch (error) {\n        return '';\n      }\n    }\n  });\n}\n"],"sourceRoot":""}